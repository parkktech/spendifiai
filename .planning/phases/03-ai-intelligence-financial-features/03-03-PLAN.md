---
phase: 03-ai-intelligence-financial-features
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - app/Services/Email/GmailService.php
  - app/Services/AI/EmailParserService.php
  - app/Services/ReconciliationService.php
  - app/Jobs/ProcessOrderEmails.php
  - app/Http/Controllers/Api/EmailConnectionController.php
  - app/Models/EmailConnection.php
  - routes/console.php
  - resources/scripts/requirements.txt
autonomous: true
user_setup:
  - service: python3
    why: "Tax export PDF/Excel generation via Python scripts"
    env_vars: []
    dashboard_config:
      - task: "Ensure Python 3 is installed and pip3 is available"
        location: "System package manager"
  - service: google-cloud
    why: "Gmail OAuth for email receipt parsing"
    env_vars:
      - name: GOOGLE_CLIENT_ID
        source: "Google Cloud Console -> APIs & Services -> Credentials -> OAuth 2.0 Client IDs"
      - name: GOOGLE_CLIENT_SECRET
        source: "Google Cloud Console -> APIs & Services -> Credentials -> OAuth 2.0 Client IDs"
    dashboard_config:
      - task: "Enable Gmail API in Google Cloud project"
        location: "Google Cloud Console -> APIs & Services -> Library -> Search 'Gmail API' -> Enable"
      - task: "Configure OAuth consent screen with gmail.readonly scope"
        location: "Google Cloud Console -> APIs & Services -> OAuth consent screen"
      - task: "Add redirect URI: http://localhost:8000/api/v1/email/callback/gmail"
        location: "Google Cloud Console -> APIs & Services -> Credentials -> OAuth client -> Authorized redirect URIs"

must_haves:
  truths:
    - "User can view tax summary by IRS Schedule C line"
    - "User can export tax packages (Excel/PDF/CSV) and download them"
    - "User can email tax exports to their accountant"
    - "User can connect Gmail via OAuth"
    - "System parses email receipts via Claude AI and creates order records with individual items"
    - "System reconciles email orders against bank transactions by matching amount, date, and merchant"
    - "Email sync runs on schedule every 6 hours"
  artifacts:
    - path: "app/Services/Email/GmailService.php"
      provides: "Gmail OAuth and email fetching service without manual encrypt/decrypt"
      min_lines: 100
    - path: "app/Services/AI/EmailParserService.php"
      provides: "Claude-powered email receipt parser"
      min_lines: 80
    - path: "app/Services/ReconciliationService.php"
      provides: "Bank transaction to email order reconciliation service using correct model names"
      contains: "App\\Models\\Transaction"
    - path: "app/Jobs/ProcessOrderEmails.php"
      provides: "Background job for email sync + parsing + reconciliation"
      contains: "email_message_id"
    - path: "app/Http/Controllers/Api/EmailConnectionController.php"
      provides: "Real Gmail OAuth flow replacing 501 stubs"
      min_lines: 40
  key_links:
    - from: "app/Http/Controllers/Api/EmailConnectionController.php"
      to: "app/Services/Email/GmailService.php"
      via: "GmailService DI for OAuth flow"
      pattern: "GmailService"
    - from: "app/Jobs/ProcessOrderEmails.php"
      to: "app/Services/AI/EmailParserService.php"
      via: "parseOrderEmail for each fetched email"
      pattern: "parser->parseOrderEmail"
    - from: "app/Jobs/ProcessOrderEmails.php"
      to: "app/Services/ReconciliationService.php"
      via: "reconcile after creating orders"
      pattern: "reconcile"
---

<objective>
Install Python dependencies for tax export, copy and fix email parsing services from expense-parser-module, implement EmailConnectionController (replacing 501 stubs), and wire reconciliation into the email processing pipeline.

Purpose: Tax export is a key revenue feature (users need their deductions for tax season). Email parsing is a core differentiator that matches vague bank charges to detailed email receipts. Both require integration of existing code with bug fixes.

Output: Working tax export (Excel/PDF/CSV), Gmail OAuth connection, email receipt parsing, and bank-to-email reconciliation.
</objective>

<execution_context>
@/home/jratz/.claude/get-shit-done/workflows/execute-plan.md
@/home/jratz/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-ai-intelligence-financial-features/03-RESEARCH.md
@existing-code/expense-parser-module/app/Services/Email/GmailService.php
@existing-code/expense-parser-module/app/Services/AI/EmailParserService.php
@existing-code/expense-parser-module/app/Services/ReconciliationService.php
@existing-code/expense-parser-module/app/Jobs/ProcessOrderEmails.php
@app/Http/Controllers/Api/EmailConnectionController.php
@app/Models/EmailConnection.php
@app/Models/ParsedEmail.php
@app/Models/Order.php
@app/Models/Transaction.php
@app/Services/TaxExportService.php
@routes/console.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Python dependencies and copy/fix email parsing services from expense-parser-module</name>
  <files>
    app/Services/Email/GmailService.php
    app/Services/AI/EmailParserService.php
    app/Services/ReconciliationService.php
    resources/scripts/requirements.txt
  </files>
  <action>
**Install Python dependencies for tax export:**

Create `resources/scripts/requirements.txt`:
```
openpyxl
reportlab
```

Run: `pip3 install openpyxl reportlab` (or `pip3 install -r resources/scripts/requirements.txt`).

Verify the Python scripts exist at `resources/scripts/generate_tax_excel.py` and `resources/scripts/generate_tax_pdf.py`. If they exist, run a quick syntax check: `python3 -c "import openpyxl; import reportlab; print('OK')"`.

**Copy EmailParserService (minimal fixes needed):**

Copy `existing-code/expense-parser-module/app/Services/AI/EmailParserService.php` to `app/Services/AI/EmailParserService.php`.

The EmailParserService is already well-written and uses the correct namespace (`App\Services\AI`). No model references to fix. No encryption issues. Just copy it as-is.

**Copy and fix GmailService (encryption double-wrapping fix):**

Copy `existing-code/expense-parser-module/app/Services/Email/GmailService.php` to `app/Services/Email/GmailService.php`. Create the `app/Services/Email/` directory if it doesn't exist.

CRITICAL FIXES in GmailService:

1. **Remove manual encrypt() calls in handleCallback()**: The EmailConnection model has `'encrypted'` casts on `access_token` and `refresh_token`. Manual `encrypt()` would double-encrypt. Change:
   ```php
   // BEFORE (double-encrypts):
   'access_token' => encrypt($token['access_token']),
   'refresh_token' => encrypt($token['refresh_token'] ?? ''),
   // AFTER (let model cast handle it):
   'access_token' => $token['access_token'],
   'refresh_token' => $token['refresh_token'] ?? '',
   ```

2. **Remove manual decrypt() calls in authenticateConnection()**: Change:
   ```php
   // BEFORE (double-decrypts):
   $this->client->setAccessToken(decrypt($connection->access_token));
   $refreshToken = decrypt($connection->refresh_token);
   // AFTER (model cast already decrypts):
   $this->client->setAccessToken($connection->access_token);
   $refreshToken = $connection->refresh_token;
   ```
   Also in the token refresh block, remove `encrypt()`:
   ```php
   // BEFORE:
   'access_token' => encrypt($newToken['access_token']),
   // AFTER:
   'access_token' => $newToken['access_token'],
   ```

3. **Fix ParsedEmail column name in fetchOrderEmails()**: Change:
   ```php
   // BEFORE:
   $exists = ParsedEmail::where('gmail_message_id', $gmailId)->exists();
   // AFTER:
   $exists = ParsedEmail::where('email_message_id', $gmailId)->exists();
   ```
   The DB column is `email_message_id`, not `gmail_message_id`.

4. **Add `status` field to handleCallback() connection update**: Add `'status' => 'active'` to the `updateOrCreate` call so the connection is marked as active after OAuth.

**Copy and fix ReconciliationService (model name fixes):**

Copy `existing-code/expense-parser-module/app/Services/ReconciliationService.php` to `app/Services/ReconciliationService.php`.

CRITICAL FIXES:

1. **Replace `BankTransaction` with `Transaction` everywhere**:
   - Change `use App\Models\BankTransaction;` to `use App\Models\Transaction;`
   - Change all `BankTransaction` type hints to `Transaction`
   - In `reconcile()`: Change `BankTransaction::where(...)` to `Transaction::where(...)`
   - In `calculateMatchScore()`: Change parameter type from `BankTransaction` to `Transaction`
   - In `applyMatch()`: Change parameter type from `BankTransaction` to `Transaction`

2. **Fix applyMatch() column name**: Change:
   ```php
   // BEFORE:
   $order->update([
       'matched_bank_transaction_id' => $transaction->plaid_transaction_id,
       'is_reconciled' => true,
   ]);
   // AFTER:
   $order->update([
       'matched_transaction_id' => $transaction->id,
       'is_reconciled' => true,
   ]);
   ```
   The Order model column is `matched_transaction_id` (not `matched_bank_transaction_id`), and it should reference the transaction's `id` (not `plaid_transaction_id`).

3. **Keep the rest intact**: The merchant normalization logic, match scoring algorithm, and tax summary method are all correct and should not be changed.
  </action>
  <verify>
```bash
python3 -c "import openpyxl; import reportlab; print('Python deps OK')"
```

```bash
php artisan about
```
Should boot without errors (all new service classes loadable).

```bash
grep -n "encrypt\|decrypt" app/Services/Email/GmailService.php
```
Should show ZERO matches for manual encrypt/decrypt calls.

```bash
grep -n "BankTransaction" app/Services/ReconciliationService.php
```
Should show ZERO matches (all replaced with Transaction).

```bash
grep -n "email_message_id" app/Services/Email/GmailService.php
```
Should show the corrected column name.
  </verify>
  <done>Python dependencies installed. EmailParserService copied. GmailService copied with encryption double-wrapping removed and column name fixed. ReconciliationService copied with BankTransaction replaced by Transaction and column names fixed. All services load without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Copy/fix ProcessOrderEmails job, update EmailConnection model, implement EmailConnectionController, and enable email sync schedule</name>
  <files>
    app/Jobs/ProcessOrderEmails.php
    app/Models/EmailConnection.php
    app/Http/Controllers/Api/EmailConnectionController.php
    routes/console.php
  </files>
  <action>
**Add sync_status to EmailConnection model $fillable:**

Read `app/Models/EmailConnection.php`. Add `'sync_status'` to the `$fillable` array. The `sync_status` column already exists in the `email_connections` DB table (migration 000001, line 21: `$table->string('sync_status')->default('pending')`). The model is currently missing it from $fillable, which would cause mass-assignment failures when ProcessOrderEmails tries to update it.

Change the $fillable from:
```php
protected $fillable = [
    'user_id', 'provider', 'email_address', 'access_token', 'refresh_token',
    'token_expires_at', 'status', 'last_synced_at',
];
```
To:
```php
protected $fillable = [
    'user_id', 'provider', 'email_address', 'access_token', 'refresh_token',
    'token_expires_at', 'status', 'last_synced_at', 'sync_status',
];
```

This is critical because:
- `ProcessOrderEmails` writes `sync_status` = 'syncing', 'completed', 'failed' (the intended pattern)
- `CategorizePendingTransactions` (line 157) queries `EmailConnection::where('sync_status', '!=', 'syncing')` to avoid syncing connections mid-sync
- Both rely on `sync_status` being a writable field

**Copy and fix ProcessOrderEmails job:**

Copy `existing-code/expense-parser-module/app/Jobs/ProcessOrderEmails.php` to `app/Jobs/ProcessOrderEmails.php`.

CRITICAL FIXES:

1. **Fix column names in ParsedEmail::create()**: Change:
   ```php
   // BEFORE:
   'gmail_message_id' => $messageId,
   'gmail_thread_id' => $emailContent['thread_id'],
   // AFTER:
   'email_message_id' => $messageId,
   'email_thread_id' => $emailContent['thread_id'],
   ```

2. **Keep ALL sync_status writes as-is**: The job's `sync_status` updates on lines 35, 152, and 163 are CORRECT and should NOT be removed. They write:
   - `'sync_status' => 'syncing'` at job start (line 35)
   - `'sync_status' => 'completed'` on success (line 152)
   - `'sync_status' => 'failed'` on failure (line 163)

   This is the intended pattern. The `CategorizePendingTransactions` scheduled task (line 157) queries `EmailConnection::where('sync_status', '!=', 'syncing')` to skip connections that are mid-sync. Removing sync_status would break that query.

3. **Fix the `$count` variable bug on line 45**: The original code has:
   ```php
   Log::info("Found {$count} new potential order emails", [
       'count' => count($messageIds),
   ]);
   ```
   `$count` is undefined. Change to:
   ```php
   $count = count($messageIds);
   Log::info("Found {$count} new potential order emails", [
       'count' => $count,
       'connection_id' => $connection->id,
   ]);
   ```

4. **Wire ReconciliationService into the job**: After the foreach loop that processes emails, add reconciliation:
   ```php
   // After all emails processed, reconcile orders with bank transactions
   if ($orders_created > 0) {
       $reconciler = app(\App\Services\ReconciliationService::class);
       $reconcileResult = $reconciler->reconcile($connection->user);
       Log::info('Reconciliation complete', $reconcileResult);
   }
   ```
   Add `use App\Models\User;` import if needed. Access user via `$connection->user` (EmailConnection belongsTo User).

**Implement EmailConnectionController (replace 501 stubs):**

Read and rewrite `app/Http/Controllers/Api/EmailConnectionController.php`. Replace all 501 stub responses with real implementations:

```php
<?php

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use App\Models\EmailConnection;
use App\Jobs\ProcessOrderEmails;
use App\Services\Email\GmailService;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;

class EmailConnectionController extends Controller
{
    public function __construct(
        private readonly GmailService $gmailService,
    ) {}

    public function connect(Request $request, string $provider): JsonResponse
    {
        if ($provider !== 'gmail') {
            return response()->json(['error' => 'Unsupported email provider. Only Gmail is supported.'], 400);
        }

        $authUrl = $this->gmailService->getAuthUrl();
        return response()->json(['auth_url' => $authUrl]);
    }

    public function callback(Request $request, string $provider): JsonResponse
    {
        if ($provider !== 'gmail') {
            return response()->json(['error' => 'Unsupported email provider'], 400);
        }

        $request->validate(['code' => 'required|string']);

        $connection = $this->gmailService->handleCallback(auth()->id(), $request->code);

        return response()->json([
            'message' => 'Gmail connected successfully',
            'email' => $connection->email_address,
        ]);
    }

    public function sync(): JsonResponse
    {
        $connection = EmailConnection::where('user_id', auth()->id())
            ->where('sync_status', '!=', 'syncing')
            ->firstOrFail();

        ProcessOrderEmails::dispatch($connection);

        return response()->json(['message' => 'Email sync started. Orders will be processed in the background.']);
    }

    public function disconnect(string $connection): JsonResponse
    {
        $emailConnection = EmailConnection::where('id', $connection)
            ->where('user_id', auth()->id())
            ->firstOrFail();

        $emailConnection->delete();

        return response()->json(['message' => 'Email connection removed']);
    }
}
```

Note: The `sync` method now checks `sync_status != 'syncing'` to prevent dispatching a new sync job while one is already running, consistent with the CategorizePendingTransactions scheduler pattern. The `callback` method uses inline validation for a single required field (`code`). This is acceptable for an OAuth callback parameter similar to how Plan 02-03 used inline validation for the deleteAccount password field.

**Enable email sync schedule in console.php:**

Read `routes/console.php`. Replace the commented-out email sync placeholder with the real implementation using `sync_status` to skip connections that are mid-sync:

```php
// ── Sync email accounts for order confirmations (every 6 hours) ──
Schedule::call(function () {
    \App\Models\EmailConnection::where('sync_status', '!=', 'syncing')->each(function ($conn) {
        \App\Jobs\ProcessOrderEmails::dispatch($conn);
    });
})->everySixHours()->name('sync-email-orders');
```

This uses `sync_status` (not `status`) because: (a) the DB column is `sync_status`, (b) `CategorizePendingTransactions` already uses the same pattern at line 157, and (c) it prevents dispatching jobs for connections that are mid-sync.

Add the necessary imports at the top of console.php if not already present:
```php
use App\Models\EmailConnection;
use App\Jobs\ProcessOrderEmails;
```
  </action>
  <verify>
```bash
php artisan about
```
Should boot without errors.

```bash
grep -n "gmail_message_id\|gmail_thread_id" app/Jobs/ProcessOrderEmails.php
```
Should show ZERO matches (all replaced with email_message_id/email_thread_id).

```bash
grep -n "sync_status" app/Jobs/ProcessOrderEmails.php
```
Should show matches for 'syncing', 'completed', 'failed' -- these are EXPECTED and correct.

```bash
grep -n "sync_status" app/Models/EmailConnection.php
```
Should show sync_status in the $fillable array.

```bash
grep -n "501" app/Http/Controllers/Api/EmailConnectionController.php
```
Should show ZERO matches (all stubs replaced).

```bash
php artisan route:list --path=api/v1/email
```
Should show email routes (connect, callback, sync, disconnect).

```bash
php artisan schedule:list
```
Should show sync-email-orders running every 6 hours (in addition to all previously registered schedules).

```bash
php artisan route:list --path=api/v1/tax
```
Should show tax routes (summary, export, send-to-accountant, download).
  </verify>
  <done>ProcessOrderEmails job copied with column names fixed (gmail_message_id -> email_message_id), sync_status writes preserved, $count bug fixed, and reconciliation wired in. EmailConnection model updated with sync_status in $fillable. EmailConnectionController implements real Gmail OAuth flow with sync_status-aware sync endpoint. Email sync schedule runs every 6 hours using sync_status to skip mid-sync connections. All email and tax routes resolve correctly.</done>
</task>

</tasks>

<verification>
1. `python3 -c "import openpyxl; import reportlab; print('OK')"` prints OK
2. `php artisan about` boots without errors
3. GmailService has NO manual encrypt/decrypt calls
4. ReconciliationService references `Transaction` (not `BankTransaction`)
5. ProcessOrderEmails uses `email_message_id` and `email_thread_id` (not gmail_ prefixed)
6. ProcessOrderEmails KEEPS sync_status writes (syncing/completed/failed)
7. EmailConnection model has sync_status in $fillable
8. EmailConnectionController has real implementations (no 501 stubs)
9. `php artisan schedule:list` shows sync-email-orders
10. `php artisan route:list --path=api/v1/email` shows all email routes
11. `php artisan route:list --path=api/v1/tax` shows all tax routes
</verification>

<success_criteria>
- Tax export works: TaxExportService can call Python scripts to generate Excel and PDF
- Gmail OAuth flow: User can initiate connection and handle callback
- Email parsing: ProcessOrderEmails fetches emails, parses via Claude, creates orders
- Reconciliation: After email sync, orders are matched to bank transactions
- sync_status field is writable on EmailConnection (in $fillable)
- sync_status writes in ProcessOrderEmails are preserved (syncing/completed/failed lifecycle)
- CategorizePendingTransactions sync_status query continues to work
- All 501 stubs are replaced with real implementations
- Email sync runs on schedule every 6 hours, skipping mid-sync connections
</success_criteria>

<output>
After completion, create `.planning/phases/03-ai-intelligence-financial-features/03-03-SUMMARY.md`
</output>
