# Security & Encryption Procedures

**Application:** [App Name TBD] — AI-Powered Expense Tracker
**Stack:** Laravel 12 / PostgreSQL / Redis / React / Plaid API / Anthropic API
**Last Updated:** February 2026

---

## Table of Contents

1. [Encryption at Rest — Complete Field Inventory](#1-encryption-at-rest)
2. [Encryption in Transit](#2-encryption-in-transit)
3. [Authentication & Session Security](#3-authentication--session-security)
4. [Authorization & Data Isolation](#4-authorization--data-isolation)
5. [API Security](#5-api-security)
6. [Input Validation & Injection Prevention](#6-input-validation--injection-prevention)
7. [Rate Limiting & Abuse Prevention](#7-rate-limiting--abuse-prevention)
8. [Secrets Management](#8-secrets-management)
9. [Third-Party API Security](#9-third-party-api-security)
10. [Data Retention & Deletion](#10-data-retention--deletion)
11. [Logging & Monitoring](#11-logging--monitoring)
12. [Deployment Security Checklist](#12-deployment-security-checklist)
13. [Incident Response Plan](#13-incident-response-plan)

---

## 1. Encryption at Rest

All encryption uses Laravel's `encrypt()` / `decrypt()` which is **AES-256-CBC** with HMAC-SHA256 authentication. The encryption key is derived from the `APP_KEY` environment variable (a 256-bit key generated by `php artisan key:generate`).

### How It Works

Laravel's encrypted cast automatically handles encryption on write and decryption on read through Eloquent model casts. **No manual `encrypt()` / `decrypt()` calls are needed** — the model handles everything transparently.

```php
// In the model:
protected function casts(): array {
    return [
        'plaid_access_token' => 'encrypted',        // Encrypt strings
        'plaid_metadata'     => 'encrypted:array',   // Encrypt + JSON encode/decode
    ];
}

// In your code — just read/write normally:
$connection->plaid_access_token = 'access-sandbox-abc123';  // Auto-encrypted on save
$token = $connection->plaid_access_token;                   // Auto-decrypted on read
```

**CRITICAL RULE:** Never call `encrypt()` or `decrypt()` manually on fields that have the `encrypted` model cast. This causes double-encryption.

### Complete Encrypted Field Inventory

| Model | Field | Cast | Why Encrypted |
|-------|-------|------|---------------|
| **User** | `password` | `hashed` (bcrypt) | User credentials — one-way hash, not reversible |
| **User** | `two_factor_secret` | `encrypted` | TOTP seed — compromise = bypass 2FA |
| **User** | `two_factor_recovery_codes` | `encrypted:array` | Backup auth codes — same risk as 2FA secret |
| **BankConnection** | `plaid_access_token` | `encrypted` | **Most critical.** Grants full read access to user's bank accounts via Plaid API |
| **BankAccount** | `ein` | `encrypted` | Federal Employer ID Number — tax identity theft risk |
| **EmailConnection** | `access_token` | `encrypted` | OAuth token granting email read access |
| **EmailConnection** | `refresh_token` | `encrypted` | Long-lived OAuth refresh — compromise = persistent email access |
| **Transaction** | `plaid_metadata` | `encrypted:array` | Raw Plaid API response — may contain sensitive account details |
| **ParsedEmail** | `raw_parsed_data` | `encrypted:array` | Parsed email body — may contain financial data, PII, purchase details |
| **UserFinancialProfile** | `monthly_income` | `encrypted` | User's stated income — sensitive financial data |
| **UserFinancialProfile** | `custom_rules` | `encrypted:array` | User categorization rules — may reveal spending patterns |

### Column Types for Encrypted Fields

**CRITICAL:** Encrypted fields **must** be stored as `TEXT` columns in the database, not `VARCHAR`, `JSON`, or `DECIMAL`. Laravel's AES-256-CBC encryption produces ciphertext that is ~200+ characters even for short plaintext values.

| Column | Wrong Type | Correct Type | Why |
|--------|-----------|--------------|-----|
| `ein` | `VARCHAR(20)` | `TEXT` | AES ciphertext >> 20 chars |
| `plaid_metadata` | `JSON` | `TEXT` | JSON columns reject encrypted strings |
| `raw_parsed_data` | `JSON` | `TEXT` | Same as above |
| `monthly_income` | `DECIMAL(12,2)` | `TEXT` | Decimal columns reject encrypted strings |
| `custom_rules` | `JSON` | `TEXT` | Same as plaid_metadata |

Migration `2026_02_10_000005_encrypt_sensitive_columns.php` handles all these column type changes.

### Fields Hidden from JSON Serialization

Every model with sensitive data has `$hidden` to prevent accidental exposure in API responses:

| Model | Hidden Fields | Reason |
|-------|--------------|--------|
| **User** | `password`, `remember_token`, `two_factor_secret`, `two_factor_recovery_codes`, `google_id` | Auth secrets, OAuth ID |
| **BankConnection** | `plaid_access_token`, `plaid_item_id`, `plaid_cursor`, `error_code`, `error_message` | Plaid internals |
| **BankAccount** | `plaid_account_id`, `ein`, `bank_connection_id` | Plaid ID, tax ID, FK |
| **EmailConnection** | `access_token`, `refresh_token` | OAuth tokens |
| **Transaction** | `plaid_transaction_id`, `plaid_metadata`, `plaid_category`, `plaid_detailed_category`, `bank_account_id` | Plaid internals |
| **ParsedEmail** | `raw_parsed_data`, `email_message_id`, `email_thread_id`, `email_connection_id`, `parse_error` | Raw data, internal IDs |
| **UserFinancialProfile** | `estimated_tax_bracket` | Tax data |

### Database-Level Encryption

In addition to application-level encryption, the PostgreSQL database should use **encryption at rest** via the hosting provider:

- **AWS RDS:** Enable storage encryption (AES-256, AWS KMS)
- **DigitalOcean Managed DB:** Encryption at rest is automatic
- **Self-hosted:** Use LUKS full-disk encryption or PostgreSQL TDE

### APP_KEY Security

The `APP_KEY` is the master encryption key. If compromised, **all encrypted data in the database is readable**.

- Generate with: `php artisan key:generate`
- **Never** commit to version control
- **Never** share across environments (staging vs production)
- Store in environment variables only
- Rotate by re-encrypting all data (requires downtime — plan accordingly)
- Back up securely (e.g., password manager, not a text file)

---

## 2. Encryption in Transit

### TLS Configuration

All client-server communication must use **TLS 1.2 or higher** (TLS 1.3 preferred).

**Required server configuration (nginx example):**
```nginx
ssl_protocols TLSv1.2 TLSv1.3;
ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384;
ssl_prefer_server_ciphers off;
ssl_session_timeout 1d;
ssl_session_cache shared:SSL:10m;
ssl_stapling on;
ssl_stapling_verify on;

# HSTS — tell browsers to always use HTTPS
add_header Strict-Transport-Security "max-age=63072000; includeSubDomains" always;
```

**Force HTTPS redirect:**
```nginx
server {
    listen 80;
    server_name yourdomain.app;
    return 301 https://$server_name$request_uri;
}
```

**Laravel middleware** (`bootstrap/app.php`):
```php
// Force HTTPS in production
if (app()->isProduction()) {
    URL::forceScheme('https');
}
```

### Internal Communication

| Connection | Encryption | How |
|-----------|-----------|-----|
| App → PostgreSQL | TLS | `DB_SSLMODE=require` in .env |
| App → Redis | TLS | `REDIS_SCHEME=tls` in .env |
| App → Plaid API | HTTPS/TLS | Enforced by Plaid (HTTPS-only API) |
| App → Anthropic API | HTTPS/TLS | Enforced by Anthropic (HTTPS-only API) |
| App → Google OAuth | HTTPS/TLS | Enforced by Google (HTTPS-only) |
| App → reCAPTCHA | HTTPS/TLS | Enforced by Google (HTTPS-only) |
| App → SMTP (email) | STARTTLS/TLS | `MAIL_ENCRYPTION=tls` in .env |

---

## 3. Authentication & Session Security

### Authentication Methods

| Method | Implementation | Details |
|--------|---------------|---------|
| Email/Password | Laravel Fortify + Sanctum | Bcrypt hashed passwords, API token auth |
| Google OAuth | Laravel Socialite | Stateless OAuth 2.0 flow |
| 2FA (optional) | TOTP via Google2FA | 6-digit codes, 30-second window, SHA1 |
| Recovery Codes | Random 10-char segments | 8 single-use codes, encrypted at rest |

### Password Security

- **Hashing:** Bcrypt via Laravel's `hashed` cast (cost factor 12)
- **Minimum length:** 8 characters (enforced by `RegisterRequest` and `ResetUserPassword`)
- **Confirmation:** Required on registration and reset (`confirmed` validation rule)
- **Change requires:** Current password verification (`current_password` rule)
- **Reset flow:** Signed, time-limited tokens (60-minute expiry)
- **On reset:** All existing API tokens revoked, failed_login_attempts reset

### Account Lockout

```
5 failed login attempts → 15-minute lockout
```

- Tracked via `failed_login_attempts` column on users table
- `locked_until` timestamp set on 5th failure
- Reset to 0 on successful login or password reset
- Prevents brute-force attacks without permanently locking accounts

### Token Security

- **Type:** Laravel Sanctum personal access tokens
- **Scope:** Single active session — all previous tokens revoked on new login
- **Revocation:** All tokens revoked on password change/reset
- **Pruning:** Expired tokens pruned automatically via `AppServiceProvider`
- **Storage:** SHA-256 hashed in `personal_access_tokens` table (plaintext only returned once at creation)

### OAuth Token Security (Google Callback)

```
SECURITY FIX: OAuth callback uses URL fragment (#) not query parameter (?)
```

- Fragment-based redirect: `{frontend}/auth/callback#token={token}&new={isNewUser}`
- Fragments are **never** sent to the server in HTTP requests
- Not stored in browser history sync, server access logs, or Referrer headers
- Frontend reads via `window.location.hash`, stores in memory, clears URL immediately

### Two-Factor Authentication Flow

1. **Enable:** User provides current password → server generates 32-char TOTP secret → returns QR code
2. **Confirm:** User scans QR, enters 6-digit code → server verifies → activates 2FA, issues 8 recovery codes
3. **Login with 2FA:** First attempt returns `{two_factor_required: true}` → second attempt includes TOTP code or recovery code
4. **Recovery code usage:** Single-use, removed from encrypted array after use
5. **Disable:** Requires current password → clears secret, codes, confirmation timestamp

---

## 4. Authorization & Data Isolation

### Policy-Based Authorization

Every data-access endpoint enforces ownership via Laravel Policies:

| Policy | Protects | Rule |
|--------|---------|------|
| `TransactionPolicy` | Transactions | `$transaction->user_id === $user->id` |
| `BankAccountPolicy` | Bank accounts | `$bankAccount->user_id === $user->id` |
| `AIQuestionPolicy` | AI questions | `$question->user_id === $user->id` |
| `SubscriptionPolicy` | Subscriptions | `$subscription->user_id === $user->id` |

**This prevents horizontal privilege escalation** — User A cannot access User B's data even if they guess the record ID.

### Route-Level Middleware

| Middleware | Purpose | Applied To |
|-----------|---------|-----------|
| `auth:sanctum` | Require valid API token | All authenticated routes |
| `bank.connected` | Require linked bank account | Transaction, subscription, savings routes |
| `profile.complete` | Require financial profile | Tax export routes |
| `2fa` | Enforce 2FA verification | N/A (handled at login for token auth) |
| `captcha` | Verify reCAPTCHA v3 token | Registration, login, forgot-password |
| `signed` | Verify signed URL | Email verification links |

---

## 5. API Security

### CSRF Protection

- **Web routes:** Laravel's built-in CSRF middleware (VerifyCsrfToken)
- **API routes:** Exempt from CSRF (use Sanctum token authentication instead)
- **Exceptions:** Plaid webhooks, email provider webhooks (validated via signatures instead)

### CORS Configuration

```php
// config/cors.php
'allowed_origins' => [env('FRONTEND_URL', 'http://localhost:3000')],
'allowed_methods' => ['GET', 'POST', 'PATCH', 'DELETE'],
'allowed_headers' => ['Content-Type', 'Authorization', 'X-Requested-With'],
'supports_credentials' => true,
```

### Sanctum SPA Authentication

For same-domain SPA deployments, Sanctum uses cookie-based session authentication with:
- Encrypted session cookies
- CSRF token verification
- Configurable stateful domains via `SANCTUM_STATEFUL_DOMAINS`

### Response Headers (add to nginx)

```nginx
add_header X-Frame-Options "SAMEORIGIN" always;
add_header X-Content-Type-Options "nosniff" always;
add_header X-XSS-Protection "1; mode=block" always;
add_header Referrer-Policy "strict-origin-when-cross-origin" always;
add_header Content-Security-Policy "default-src 'self'; script-src 'self' https://www.google.com https://www.gstatic.com; frame-src https://cdn.plaid.com;" always;
```

---

## 6. Input Validation & Injection Prevention

### SQL Injection Prevention

- **All queries** use Eloquent ORM with parameterized bindings — no raw SQL
- Route model binding resolves models by ID automatically
- No user input is ever concatenated into query strings

### XSS Prevention

- React frontend auto-escapes all rendered content
- API responses return JSON (not HTML) — no template injection risk
- Laravel's Blade templating (if used) auto-escapes with `{{ }}` syntax

### Mass Assignment Protection

Every model explicitly defines `$fillable` — only whitelisted fields can be set via `Model::create()` or `$model->update()`. Sensitive fields like `id`, `user_id`, `created_at` are not fillable.

### Form Request Validation

All input is validated via dedicated FormRequest classes before reaching controllers:

| Request Class | Validates | Rules |
|--------------|-----------|-------|
| `RegisterRequest` | Registration | name (required, max:255), email (required, unique), password (min:8, confirmed), captcha_token |
| `LoginRequest` | Login | email (required), password (required), captcha_token, optional two_factor_code |

### reCAPTCHA v3 (Invisible)

- **Integration:** Server-side verification via `CaptchaService`
- **Threshold:** Score ≥ 0.5 (0.0 = likely bot, 1.0 = likely human)
- **Action validation:** Each form sends a unique action name, verified server-side to prevent token reuse
- **Fail closed:** If verification fails for any reason, the request is rejected
- **Graceful degradation:** Captcha disabled when `RECAPTCHA_SITE_KEY` is not set (local dev only)

---

## 7. Rate Limiting & Abuse Prevention

### Endpoint Rate Limits

| Endpoint | Limit | Purpose |
|---------|-------|---------|
| `POST /api/auth/register` | 5/minute | Prevent mass account creation |
| `POST /api/auth/login` | 10/minute | Prevent credential stuffing |
| `POST /api/auth/forgot-password` | 3/minute | Prevent email bombing |
| `POST /api/auth/reset-password` | 5/minute | Prevent token brute-force |
| `POST /api/auth/email/resend` | 3/minute | Prevent verification email abuse |

### Account-Level Protection

- **Account lockout:** 5 failed attempts → 15-minute lock
- **Token revocation:** New login revokes all previous tokens
- **Email enumeration prevention:** Forgot-password always returns success regardless of whether email exists

---

## 8. Secrets Management

### Environment Variables — Complete List

| Variable | Sensitivity | Notes |
|----------|-----------|-------|
| `APP_KEY` | **CRITICAL** | Master encryption key — protects all encrypted DB fields |
| `DB_PASSWORD` | **CRITICAL** | Database access |
| `PLAID_SECRET` | **CRITICAL** | Plaid API secret — grants access to user bank data |
| `ANTHROPIC_API_KEY` | HIGH | Claude API key — usage-billed |
| `GOOGLE_CLIENT_SECRET` | HIGH | OAuth authentication secret |
| `RECAPTCHA_SECRET_KEY` | HIGH | Server-side captcha verification |
| `MAIL_PASSWORD` | HIGH | Email sending credentials |
| `REDIS_PASSWORD` | HIGH | Cache/queue access |
| `PLAID_CLIENT_ID` | MEDIUM | Plaid client identifier |
| `GOOGLE_CLIENT_ID` | LOW | Public OAuth client ID |
| `RECAPTCHA_SITE_KEY` | LOW | Public captcha site key |

### Rules

1. **Never commit `.env` to version control** — `.gitignore` must include `.env`
2. **Never log secrets** — scrub API keys from log output
3. **Use hosting provider's secrets manager** for production (AWS Secrets Manager, DigitalOcean App Platform env vars, etc.)
4. **Separate keys per environment** — dev, staging, production each get unique `APP_KEY`, database credentials, API keys
5. **Rotate on compromise** — if any key is exposed, rotate immediately and re-encrypt affected data

---

## 9. Third-Party API Security

### Plaid

| Security Measure | Implementation |
|-----------------|----------------|
| Access tokens encrypted at rest | `'plaid_access_token' => 'encrypted'` model cast |
| Tokens never exposed to frontend | `$hidden` array on BankConnection model |
| Webhook signature verification | Verify `Plaid-Verification` header (TODO: implement) |
| Item removal on disconnect | Call `POST /item/remove` (TODO: implement endpoint) |
| Minimal data retention | Only store masked account numbers (last 4 digits) |
| Environment separation | Sandbox for dev, Production for live |

### Anthropic (Claude API)

| Security Measure | Implementation |
|-----------------|----------------|
| API key in env only | `config('services.anthropic.api_key')` |
| No PII sent to API | Transaction descriptions only — no names, account numbers, or SSNs |
| Rate limiting | Configurable delay between API calls (`rate_limit_ms`) |
| Response validation | Validate JSON structure before storing AI categorizations |

### Google OAuth

| Security Measure | Implementation |
|-----------------|----------------|
| Stateless OAuth flow | `Socialite::driver('google')->stateless()` |
| Client secret in env only | `config('services.google.client_secret')` |
| Email auto-verified | Google-authenticated emails marked verified immediately |
| Disconnect requires password | Prevents lockout if Google is the only auth method |

---

## 10. Data Retention & Deletion

### Retention Schedule

| Data Type | Retention Period | Justification |
|----------|-----------------|---------------|
| Active account data | While account active | Required for service |
| Transaction history | User-configurable (default 3 years) | Tax record keeping |
| Plaid access tokens | While bank connection active | Required for sync |
| AI categorization data | With associated transaction | Part of transaction record |
| Parsed email data | 90 days after processing | Needed for reconciliation |
| Session tokens | Auto-expire on inactivity | Pruned automatically |
| AI questions | 7 days if unanswered | Expired by scheduled task |
| Failed login attempts | Reset on successful login | Security tracking |

### Deletion Procedures (TODO: Implement)

**Account deletion endpoint** (`DELETE /api/v1/account`):
1. Revoke all Plaid access tokens via `POST /item/remove` for each connection
2. Delete all user data: transactions, subscriptions, bank connections, email connections, parsed emails, orders, AI questions, savings data, budget goals, financial profile
3. Delete user record
4. Confirm deletion via email
5. Log deletion event (retain audit log for 90 days)

**Bank disconnection** (`DELETE /api/v1/accounts/{connection}`):
1. Call Plaid `POST /item/remove` to revoke access token
2. Delete BankConnection record (cascades to BankAccounts)
3. Retain historical transactions (unless user requests deletion)

---

## 11. Logging & Monitoring

### What to Log

| Event | Log Level | Details |
|-------|----------|---------|
| Successful login | INFO | user_id, IP, user_agent |
| Failed login | WARNING | email, IP, attempt_count |
| Account lockout | WARNING | email, IP, locked_until |
| Password reset requested | INFO | email (not the token) |
| Password changed | INFO | user_id |
| 2FA enabled/disabled | INFO | user_id |
| Bank connected/disconnected | INFO | user_id, institution_name |
| API rate limit hit | WARNING | endpoint, IP |
| Plaid webhook received | INFO | webhook_type, item_id |
| Account deleted | INFO | user_id, deletion_timestamp |

### What to NEVER Log

- Passwords (plaintext or hashed)
- API keys or secrets
- Plaid access tokens
- OAuth tokens
- 2FA secrets or recovery codes
- Full credit card or account numbers
- Social Security Numbers or EINs
- User's monthly income
- Email content/body
- Raw Plaid API responses

### Monitoring Alerts (Set Up in Production)

- 10+ failed logins from same IP in 5 minutes → possible brute force
- 50+ failed logins across any accounts in 5 minutes → possible credential stuffing
- Any 500 error on auth endpoints → potential security issue
- Plaid webhook signature verification failure → possible webhook spoofing
- APP_KEY change detected → immediate investigation

---

## 12. Deployment Security Checklist

### Before First Deploy

- [ ] `APP_ENV=production` and `APP_DEBUG=false`
- [ ] Unique `APP_KEY` generated for production (NEVER reuse from dev)
- [ ] All API keys are production keys (not sandbox/test)
- [ ] HTTPS enforced with valid TLS certificate
- [ ] TLS 1.0 and 1.1 disabled
- [ ] SSL Labs test score ≥ A (test at ssllabs.com/ssltest)
- [ ] HSTS header enabled
- [ ] Security headers configured (X-Frame-Options, CSP, etc.)
- [ ] `.env` not accessible via web (not in public directory)
- [ ] `storage/` and `bootstrap/cache/` not web-accessible
- [ ] Database encrypted at rest (hosting provider feature)
- [ ] Database connections use TLS (`DB_SSLMODE=require`)
- [ ] Redis connections use TLS (if remote)
- [ ] SSH key-only access (password SSH disabled)
- [ ] Firewall: only ports 80, 443, 22 open
- [ ] Database port (5432) not publicly accessible
- [ ] MFA enabled on hosting provider account
- [ ] MFA enabled on GitHub account
- [ ] MFA enabled on Plaid dashboard
- [ ] MFA enabled on domain registrar
- [ ] Dependabot enabled for dependency vulnerability alerts
- [ ] `composer audit` shows 0 vulnerabilities
- [ ] `npm audit` shows 0 critical vulnerabilities
- [ ] Privacy policy published at /privacy
- [ ] Terms of service published at /terms
- [ ] Disk encryption enabled on all development machines

### Regular Maintenance (Monthly)

- [ ] Run `composer audit` and `npm audit`
- [ ] Review and apply dependency updates
- [ ] Check SSL certificate expiration
- [ ] Review access logs for anomalies
- [ ] Verify all MFA is still active on external accounts
- [ ] Review and rotate any API keys approaching 1 year old
- [ ] Test backup restoration procedure
- [ ] Review and prune expired sessions/tokens

### Annual

- [ ] Review and update Information Security Policy
- [ ] Review and update Privacy Policy
- [ ] Review data retention compliance
- [ ] Conduct security self-assessment
- [ ] Rotate production `APP_KEY` (requires re-encryption of all encrypted data)
- [ ] Review all third-party integrations for least-privilege access

---

## 13. Incident Response Plan

### Severity Levels

| Level | Description | Example | Response Time |
|-------|------------|---------|---------------|
| **P1 — Critical** | Active data breach or credential compromise | APP_KEY leaked, database dumped, Plaid tokens exposed | Immediately |
| **P2 — High** | Vulnerability with potential for data exposure | SQL injection found, auth bypass discovered | Within 4 hours |
| **P3 — Medium** | Security issue without active exploitation | Outdated dependency with known CVE, misconfigured header | Within 24 hours |
| **P4 — Low** | Best practice improvement | Minor CSP adjustment, logging enhancement | Within 1 week |

### Response Steps (P1 — Critical)

1. **Contain:** Immediately revoke compromised credentials, rotate APP_KEY, take affected systems offline if necessary
2. **Assess:** Determine scope — which users affected, what data exposed, how long was the exposure
3. **Remediate:** Fix the root cause, re-encrypt data with new keys, force password reset for affected users
4. **Notify:** Inform affected users within 72 hours (CCPA/GDPR requirement), notify Plaid if their tokens were compromised
5. **Review:** Post-incident review, document lessons learned, update security procedures

### If APP_KEY Is Compromised

This is the worst-case scenario — all encrypted fields become readable.

1. Generate new APP_KEY immediately
2. Take the application offline
3. Write a migration to re-encrypt ALL encrypted fields with the new key:
   - Decrypt each field with the old key
   - Re-encrypt with the new key
   - Update the database
4. Rotate all Plaid access tokens (disconnect and reconnect all bank accounts)
5. Invalidate all OAuth tokens
6. Force password reset for all users (passwords are bcrypt-hashed, not AES-encrypted, so they're safe — but do it anyway as a precaution)
7. Notify all users of the breach
8. Investigate how the key was leaked and close the vector

---

## Appendix A: Encryption Decision Matrix

**When deciding whether a field needs encryption, use this matrix:**

| Question | If YES → |
|----------|----------|
| Could this grant access to an external system? (API tokens, OAuth tokens) | **Encrypt** |
| Is this a government-issued identifier? (EIN, SSN, passport) | **Encrypt** |
| Is this financial data that reveals income, wealth, or spending patterns? | **Encrypt** |
| Could this data be used for identity theft? | **Encrypt** |
| Does this contain raw third-party API responses? | **Encrypt** |
| Does this contain email body content? | **Encrypt** |
| Is this a user credential or authentication secret? | **Hash** (bcrypt) if password, **encrypt** if token |
| Is this just a display label or category name? | No encryption needed |
| Is this an amount on an individual transaction? | No encryption needed (too many records, low individual risk) |

## Appendix B: Files Modified in Security Audit

| File | Changes Made |
|------|-------------|
| `app/Models/BankAccount.php` | Added `$hidden` (plaid_account_id, ein, bank_connection_id), added `'ein' => 'encrypted'` cast |
| `app/Models/BankConnection.php` | Added `$hidden` (plaid_access_token, plaid_item_id, plaid_cursor, error_code, error_message) |
| `app/Models/EmailConnection.php` | Added `$hidden` (access_token, refresh_token), expanded from one-liner format |
| `app/Models/User.php` | Changed `two_factor_recovery_codes` cast from `'encrypted'` to `'encrypted:array'` |
| `app/Models/UserFinancialProfile.php` | Added `$hidden` (estimated_tax_bracket), encrypted `monthly_income`, encrypted `custom_rules` as `encrypted:array`, added accessor |
| `app/Models/ParsedEmail.php` | Aligned fields to migration schema, added `$hidden`, added `'raw_parsed_data' => 'encrypted:array'` |
| `app/Models/Transaction.php` | Added `$hidden` (plaid_transaction_id, plaid_metadata, plaid_category, plaid_detailed_category, bank_account_id), changed `plaid_metadata` to `'encrypted:array'` |
| `app/Services/PlaidService.php` | Removed manual `encrypt()`/`decrypt()` calls — model cast handles it |
| `app/Http/Controllers/Auth/AuthController.php` | Removed manual `decrypt()`/`encrypt()` in `verifyTwoFactorCode()` |
| `app/Http/Controllers/Auth/TwoFactorController.php` | Removed all manual `encrypt()`/`decrypt()`/`json_encode()`/`json_decode()` calls |
| `app/Http/Controllers/Auth/SocialAuthController.php` | Changed OAuth redirect from query param (`?token=`) to URL fragment (`#token=`) |
| `database/migrations/000002_add_account_purpose.php` | Changed `ein` from `string(20)` to `text()` for encrypted storage |
| `database/migrations/000005_encrypt_sensitive_columns.php` | **NEW.** Changes column types: plaid_metadata (json→text), raw_parsed_data (json→text), monthly_income (decimal→text), custom_rules (json→text) |
